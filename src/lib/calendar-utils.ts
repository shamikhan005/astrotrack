import { createEvents, EventAttributes, DateArray } from 'ics';
import { v4 as uuidv4 } from 'uuid';
import { CalendarEvent, CalendarExportOptions, ReminderTiming } from '@/types/calendar';
import { AstronomicalEvent } from '@/types/astro-events';

export function astronomicalEventToCalendarEvent(astroEvent: AstronomicalEvent): CalendarEvent {
  const startDate = new Date(astroEvent.date);
  
  if (isNaN(startDate.getTime())) {
    console.error(`Invalid date for event ${astroEvent.name}: ${astroEvent.date}`);
    startDate.setTime(Date.now());
  }
  
  let endDate: Date;
  
  switch (astroEvent.type) {
    case 'meteor-shower':
      if (astroEvent.date.includes('T')) {
        endDate = new Date(startDate.getTime() + (3 * 60 * 60 * 1000)); 
      } else {
        endDate = new Date(startDate.getTime() + (3 * 60 * 60 * 1000));
      }
      break;
      
    case 'planetary-conjunction':
      endDate = new Date(startDate.getTime() + (2 * 60 * 60 * 1000));
      break;
      
    case 'eclipse':
      if (astroEvent.duration) {
        const durationMs = parseDuration(astroEvent.duration);
        endDate = new Date(startDate.getTime() + durationMs);
      } else {
        endDate = new Date(startDate.getTime() + (2 * 60 * 60 * 1000));
      }
      break;
      
    case 'iss-flyover':
      if (astroEvent.duration) {
        const durationMs = parseDuration(astroEvent.duration);
        endDate = new Date(startDate.getTime() + durationMs);
      } else {
        endDate = new Date(startDate.getTime() + (5 * 60 * 1000)); 
      }
      break;
      
    case 'space-mission':
      endDate = new Date(startDate.getTime() + (30 * 60 * 1000));
      break;
      
    case 'other':
      endDate = new Date(startDate.getTime() + (60 * 60 * 1000));
      break;
      
    default:
      endDate = new Date(startDate.getTime() + (2 * 60 * 60 * 1000));
      break;
  }
  
  return {
    title: `ðŸŒŸ ${astroEvent.name}`,
    description: createEventDescription(astroEvent),
    start: startDate,
    end: endDate,
    location: astroEvent.visibility?.coordinates ? 
      `${astroEvent.visibility.coordinates.latitude.toFixed(4)}, ${astroEvent.visibility.coordinates.longitude.toFixed(4)}` : 
      undefined,
    url: astroEvent.externalUrl,
    uid: uuidv4(),
    categories: [astroEvent.type, 'astronomy', 'space'],
    status: 'CONFIRMED'
  };
}

function parseDuration(duration: string): number {
  if (duration.includes('minutes')) {
    const minutes = parseInt(duration.match(/\d+/)?.[0] || '0');
    return minutes * 60 * 1000;
  } else if (duration.includes('hours')) {
    const hours = parseInt(duration.match(/\d+/)?.[0] || '0');
    return hours * 60 * 60 * 1000;
  } else if (duration.includes('days')) {
    const days = parseInt(duration.match(/\d+/)?.[0] || '0');
    return days * 24 * 60 * 60 * 1000;
  } else {
    const num = parseInt(duration.match(/\d+/)?.[0] || '120');
    return num * 60 * 1000; 
  }
}

function createEventDescription(event: AstronomicalEvent): string {
  let description = event.description + '\n\n';
  
  description += `Event Type: ${event.type.replace('-', ' ').toUpperCase()}\n`;
  description += `Source: ${event.source}\n`;
  
  if (event.duration) {
    description += `Duration: ${event.duration}\n`;
  }
  
  if (event.visibility) {
    description += '\nVisibility Information:\n';
    description += `â€¢ Visible to naked eye: ${event.visibility.visibleToNakedEye ? 'Yes' : 'No'}\n`;
    
    if (event.visibility.bestViewingTime) {
      description += `â€¢ Best viewing time: ${event.visibility.bestViewingTime}\n`;
    }
    
    if (event.visibility.equipment) {
      description += `â€¢ Equipment needed: ${event.visibility.equipment}\n`;
    }
    
    if (event.visibility.hemisphere) {
      description += `â€¢ Visible from: ${event.visibility.hemisphere} hemisphere\n`;
    }
  }
  
  if (event.externalUrl) {
    description += `\nMore information: ${event.externalUrl}`;
  }
  
  description += '\n\nðŸŒŸ Generated by AstroTrack - Your cosmic event companion';
  
  return description;
}

export async function generateICalFile(events: AstronomicalEvent[]): Promise<string> {
  const calendarEvents: EventAttributes[] = events.map(event => {
    const calEvent = astronomicalEventToCalendarEvent(event);
    const startDate = calEvent.start;
    const endDate = calEvent.end || new Date(startDate.getTime() + (2 * 60 * 60 * 1000));
    
    return {
      title: calEvent.title,
      description: calEvent.description,
      start: dateToDateArray(startDate),
      end: dateToDateArray(endDate),
      location: calEvent.location,
      url: calEvent.url,
      uid: calEvent.uid,
      categories: calEvent.categories,
      status: calEvent.status || 'CONFIRMED',
      organizer: { name: 'AstroTrack', email: 'noreply@astrotrack.app' },
      productId: 'astrotrack/1.0.0'
    };
  });

  return new Promise((resolve, reject) => {
    createEvents(calendarEvents, (error, value) => {
      if (error) {
        reject(error);
      } else {
        resolve(value || '');
      }
    });
  });
}

function dateToDateArray(date: Date): DateArray {
  return [
    date.getFullYear(),
    date.getMonth() + 1,
    date.getDate(),
    date.getHours(),
    date.getMinutes()
  ];
}

export function generateGoogleCalendarUrl(event: AstronomicalEvent): string {
  const calEvent = astronomicalEventToCalendarEvent(event);
  const startDate = calEvent.start;
  const endDate = calEvent.end || new Date(startDate.getTime() + (2 * 60 * 60 * 1000));
  
  const formatDateForGoogle = (date: Date): string => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    
    return `${year}${month}${day}T${hours}${minutes}${seconds}`;
  };
  
  const formattedStart = formatDateForGoogle(startDate);
  const formattedEnd = formatDateForGoogle(endDate);
  
  const params = new URLSearchParams({
    action: 'TEMPLATE',
    text: calEvent.title,
    dates: `${formattedStart}/${formattedEnd}`,
    details: calEvent.description,
    location: calEvent.location || '',
    trp: 'false'
  });
  
  return `https://calendar.google.com/calendar/render?${params.toString()}`;
}

export function generateOutlookCalendarUrl(event: AstronomicalEvent): string {
  const calEvent = astronomicalEventToCalendarEvent(event);
  const startDate = calEvent.start;
  const endDate = calEvent.end || new Date(startDate.getTime() + (2 * 60 * 60 * 1000));
  
  const formatDateForOutlook = (date: Date): string => {
    const offset = date.getTimezoneOffset();
    const localTime = new Date(date.getTime() - (offset * 60 * 1000));
    return localTime.toISOString().split('.')[0];
  };
  
  const params = new URLSearchParams({
    path: '/calendar/action/compose',
    rru: 'addevent',
    subject: calEvent.title,
    startdt: formatDateForOutlook(startDate),
    enddt: formatDateForOutlook(endDate),
    body: calEvent.description,
    location: calEvent.location || ''
  });
  
  return `https://outlook.live.com/calendar/0/deeplink/compose?${params.toString()}`;
}

export function downloadFile(content: string, filename: string, mimeType: string = 'text/calendar'): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

export function reminderTimingToMs(timing: ReminderTiming, customMs?: number): number {
  switch (timing) {
    case '15min':
      return 15 * 60 * 1000;
    case '1hour':
      return 60 * 60 * 1000;
    case '1day':
      return 24 * 60 * 60 * 1000;
    case '1week':
      return 7 * 24 * 60 * 60 * 1000;
    case 'custom':
      return customMs || 60 * 60 * 1000; 
    default:
      return 60 * 60 * 1000;
  }
}

export async function checkNotificationPermission(): Promise<boolean> {
  if (!('Notification' in window)) {
    console.warn('This browser does not support notifications');
    return false;
  }
  
  if (Notification.permission === 'granted') {
    return true;
  }
  
  if (Notification.permission === 'default') {
    const permission = await Notification.requestPermission();
    return permission === 'granted';
  }
  
  return false;
}

export function scheduleNotification(
  event: AstronomicalEvent, 
  reminderTime: Date,
  message?: string
): string {
  const notificationId = uuidv4();
  const now = new Date().getTime();
  const reminderMs = reminderTime.getTime();
  const delay = reminderMs - now;
  
  if (delay <= 0) {
    console.warn('Reminder time is in the past');
    return notificationId;
  }
  
  setTimeout(() => {
    if ('Notification' in window && Notification.permission === 'granted') {
      const notification = new Notification(`ðŸŒŸ ${event.name}`, {
        body: message || `${event.name} is starting soon! ${event.description.slice(0, 100)}...`,
        icon: '/favicon.ico',
        tag: notificationId,
        requireInteraction: true,
        data: {
          eventId: event.id,
          eventUrl: event.externalUrl
        }
      });
      
      notification.onclick = () => {
        window.focus();
        notification.close();
      };
    }
  }, delay);
  
  return notificationId;
}

export async function exportEvents(
  events: AstronomicalEvent[], 
  options: CalendarExportOptions
): Promise<void> {
  const filteredEvents = events.filter(event => {
    const eventDate = new Date(event.date);
    const inDateRange = eventDate >= options.dateRange.start && eventDate <= options.dateRange.end;
    const typeMatches = options.eventTypes.length === 0 || options.eventTypes.includes(event.type);
    return inDateRange && typeMatches;
  });
  
  if (filteredEvents.length === 0) {
    alert('No events match the selected criteria.');
    return;
  }
  
  switch (options.format) {
    case 'ics': {
      const icalContent = await generateICalFile(filteredEvents);
      const filename = `astrotrack-events-${new Date().toISOString().split('T')[0]}.ics`;
      downloadFile(icalContent, filename, 'text/calendar');
      break;
    }
    case 'google': {
      if (filteredEvents.length === 1) {
        window.open(generateGoogleCalendarUrl(filteredEvents[0]), '_blank');
      } else {
        alert(`Selected ${filteredEvents.length} events. Please use iCal export for multiple events, or select individual events for Google Calendar.`);
      }
      break;
    }
    case 'outlook': {
      if (filteredEvents.length === 1) {
        window.open(generateOutlookCalendarUrl(filteredEvents[0]), '_blank');
      } else {
        alert(`Selected ${filteredEvents.length} events. Please use iCal export for multiple events, or select individual events for Outlook.`);
      }
      break;
    }
  }
} 